[{"title":"vue之axios的简单封装及使用","date":"2018-05-07T06:46:40.000Z","path":"2018/05/07/vue之axios的简单封装及使用/","text":"vue之axios的简单封装及使用前言vue更新到2.0之后，作者就宣告不再对vue-resource更新，而是推荐的axios,axios和其他的ajax库都是很类似的，提供了2种使用的方式,都可以简单的调用。其实网上及官方都有很多说明及例子，也很简单的就能学习到如何运用，这里我就不一一说明了。我这里主要记录一个参考了很多的例子及自己常用的封装方法。 引入方式 axios 主要针对vue脚手架搭建，直接在命令行中运行 npm install axios --save 目录结构 我的目录结构 在src文件夹下创建一个api文件夹，然后分别创建三个JS文件：config.js:用来配置公共参数的文件,fetch.js：axios配置参数相关文件,index.js：入口文件 配置详情 首先配置接口需要的公共参数，在config.js中配置，大致如下： 123456789101112const DEV_HOST = '接口域名'const code = &#123; 公共参数1: 1, 公共参数2: 2, 公共参数3: 3&#125;module.exports = &#123; code: code, DEV_HOST: DEV_HOST&#125; 然后配置axios参数并引入公共参数，在fetch.js中配置，大致如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import axios from 'axios'import qs from 'qs'import &#123; DEV_HOST &#125; from './config'const instance = axios.create(&#123; // 设置默认根地址 baseURL: DEV_HOST, // 设置请求超时设置 timeout: 5000, // 设置请求时的header header: &#123; 'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8', &#125;, // 公用参数 data: &#123;&#125;&#125;)// POST传参序列化instance.interceptors.request.use((config) =&gt; &#123; //console.log(config) if (config.method === 'post') &#123; config.data = qs.stringify(config.data) &#125; return config&#125;, (error) =&gt; &#123; return Promise.reject(error)&#125;)// 返回状态判断instance.interceptors.response.use((res) =&gt; &#123; if (res.data.code == 400) &#123; console.log(\"接口请求超时或者错误\") &#125; return res&#125;, (error) =&gt; &#123; return Promise.reject(error)&#125;)export default function fetch(options) &#123; return new Promise((resolve, reject) =&gt; &#123; instance(options).then(response =&gt; &#123; resolve(response.data) &#125;).catch((error) =&gt; &#123; reject(error) &#125;) &#125;)&#125; 最后在入口文件index.js中写好接口地址，供使用时调用,大致如下： 1234567import fetch from './fetch'//接口1export const 接口1命名 = (data) =&gt; fetch(&#123; url: '接口1地址', method: 'POST', data &#125;);//接口2export const 接口2命名 = (data) =&gt; fetch(&#123; url: '接口2地址', method: 'POST', data &#125;); 使用方法 使用时，在需要调用接口的页面中，调用接口1命名，并在method中调用fetch方法，代码大致如下： 1234567891011121314151617import &#123; 接口1命名 &#125; from \"@/api\";export default &#123; data() &#123; return &#123; 参数1 &#125;, methods: &#123; click() &#123; 接口1命名(参数1).then(res =&gt; &#123; console.log(res) &#125;) .catch(err =&gt; &#123; console.log(err) &#125;); &#125; &#125;&#125; 总结这就是我常用的axios的使用方法，用习惯了，就觉得应该来记录一下。其他如果项目简单的话，并不需要在fetch中写那么多的参数。直接调用post及get方法，在fetch中直接全部替换以下代码使用即可： 12345678910111213141516171819202122232425262728export default &#123; post(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; instance(&#123; method: 'post', url, data: params, &#125;).then(response =&gt; &#123; resolve(response.data) &#125;).catch((error) =&gt; &#123; reject(error) &#125;) &#125;) &#125;, get(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; instance(&#123; method: 'get', url, params: params, &#125;).then(response =&gt; &#123; resolve(response.data) &#125;).catch((error) =&gt; &#123; reject(error) &#125;) &#125;) &#125;&#125; 希望自己的记录对大家有帮助，欢迎指教与参与讨论。","tags":[{"name":"vue","slug":"vue","permalink":"https://linyong05.github.io/tags/vue/"},{"name":"axios","slug":"axios","permalink":"https://linyong05.github.io/tags/axios/"}]},{"title":"vue之HTML转为PDF并预览的实现与踩坑过程","date":"2018-04-23T09:29:12.000Z","path":"2018/04/23/vue之HTML转为PDF并预览的实现与踩坑过程/","text":"vue之HTML转为PDF并预览的实现与踩坑过程前言产品的话能不听吗？产品：”我觉得我们的后台需要一份导出功能，普通的word、excel导出不适用，导出来的数据容易误操作，还容易被修改。不理想,我就需要一份PDF导出格式,你们去实现一下。。。” 好吧，产品的话只能听啊，那就去实现吧。虽然平时没做过PDF导出，但至少也还在度娘在啊。搜索一番并历经几个小坑，终于是实现较理想的状态。以下听我来细细讲解一番。此次分享以VUE项目为主，也许网上也有很多的教程，但是自己亲身经历的还是有意义的。 准备材料 jspdf 项目地址：https://github.com/MrRio/jsPDF html2canvas 项目地址：https://github.com/niklasvh/html2canvas 安装 jspdf 直接在命令行中运行npm install jspdf –save 命令行中运行 html2canvas 不要用Github文档的npm安装的方式，直接下载文件放入文件夹。如图： 下载入口 Github文档有npm安装的方式,不过安装下来是5.0以上版本的预发行版本（这也是我没注意遇到的大坑，版本下载错了，以下方法都实现不了哦），所以不要直接用，我们去下载最新发布的版本0.4.1。 最新版本 将下载完的html2canvas.js放在项目的指定位置中供后面使用来调用，这个位置可根据你的项目自行选择,下图是我所放的位置。 放到项目指定位置 使用HTML转为PDF并预览的方法其实有很多很多，我介绍的这个HTML转为PDF并预览主要针对转换需求少的，不能实现批量，目前我是没看到有啥可以实现批量转换的，有好的方法也希望大家告知，我的实现过程主要是，打开需要转为PDF的页面，然后再点击转为PDF的按钮，通过ifranme展示转换好的PDF，用户可以通过当前的页面自行选择是否需要下载PDF。 第一步，引用 需要转为PDF的页面的script中引用 import jsPDF from ‘jspdf’ import html2canvas from ‘../../../assets/js/html2canvas.js’ 第二步，写页面布局（即需要打印的页面） 页面上需要一个布局作为转换页面的模板，还需要一个iframe来展示转换后的PDF预览结果，期间转换后通过隐藏模板显示预览来完成。在template内的基本布局如下。 123456789101112&lt;template&gt;&lt;div&gt; &lt;div v-show=\"!pdfShow\"&gt; &lt;button @click=\"LoadPDF\"&gt;预览PDF&lt;/button&gt; &lt;div id=\"pdfdiv\" class=\"pdfbg\"&gt; &lt;p&gt;我是需要打印的内容&lt;/p&gt; &lt;img src=\"https://img.alicdn.com/bao/uploaded/TB1qimQIpXXXXXbXFXXSutbFXXX.jpg\" width=\"100\" height=\"auto\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;iframe id=\"iframe\" scrolpng=\"no\" frameborder=\"0\" v-show=\"pdfShow\" width=\"100%\" height=\"auto\"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/template&gt; 第三步，写按钮方法 因为需要显示隐藏控制，我们需要双向绑定一个pdfShow,然后写一个按钮的点击事件LoadPDF()。 data()中return一个pdfShow，默认不显示PDF： 12345data() &#123; return &#123; pdfShow: false //默认不显示PDF预览ifranme &#125;&#125; methods中添加一个LoadPDF()为按钮的点击事件： 1234567891011121314151617methods: &#123; LoadPDF() &#123; var pdf = new jsPDF(); pdf.internal.scaleFactor = 8; //可以调整缩放比例 var options = &#123; pagesplit: true, //分页 \"background\": '#FFFFFF' //设置背景色 &#125;; pdf.addHTML(document.querySelector('#pdfdiv'), options, () =&gt; &#123; pdf.setProperties(&#123; title: 'PDF预览' //设置PDF标题 &#125;); document.getElementById(\"iframe\").src = pdf.output('datauristring'); //在iframe中显示 this.pdfShow = true //显示PDF预览 &#125;); &#125;&#125; 到此其实基本上已经实现了PDF预览功能了，但是呢，还是有些小坑的，就比如你完完全全的按我这个步骤做下来是绝对会遇到坑的。接下来我就来介绍下所遇到的坑并如何爬过这些坑。 爬坑此方法坑有三处 1.生成PDF可能会出现可能会出现黑色区域一大片。实际PDF转换是成功的，原因在于你的页面要转换区域没有背景样式，需要加个白色背景，如我的class名为pdfbg,设置为:background:&quot;#FFFFFF&quot;; 2.可能生成的PDF位置偏移或者文字变形，那是由于项目设置的单位不同，可以先尝试修改pdf.internal.scaleFactor = 8;调整缩放比例来调整到最佳显示。 3.页面中存在图片转换不显示图片的问题，原因是网络图片存在跨域等问题，解决方案是将图片转换为base64即可。通过修改img中的图片地址的&lt;img :src=&quot;FormatImg(https://img.alicdn.com/bao/uploaded/TB1qimQIpXXXXXbXFXXSutbFXXX.jpg)&quot; width=&quot;100&quot; height=&quot;auto&quot;&gt;传入FormatImg(url)即可(vue中需要用到:src绑定)。方法以下贴出（这是针对单张图片的方法，可自行修改多张）：1234567891011121314151617181920212223methods: &#123; getBase64Image(img) &#123; var canvas = document.createElement(\"canvas\"); canvas.width = img.width; canvas.height = img.height; var ctx = canvas.getContext(\"2d\"); ctx.drawImage(img, 0, 0, img.width, img.height); var ext = img.src.substring(img.src.lastIndexOf(\".\") + 1).toLowerCase(); var dataURL = canvas.toDataURL(\"image/\" + ext); return dataURL; &#125;, FormatImg(url) &#123; let _this = this var img = url var image = new Image(); image.crossOrigin = ''; image.src = img; image.onload = function() &#123; _this.baseimg = _this.getBase64Image(image); &#125; return _this.baseimg &#125;&#125; vue之HTML转为PDF第二种方法(跳过预览下载PDF)第二种方法我也是网上看到的，只是小试了下，其实原理差不多，具体的不详细介绍，也并未认真的去修改配置。这里也贴出代码，有需要的自己试下。 jspdf 项目地址：https://github.com/MrRio/jsPDF html2canvas 项目地址：https://github.com/niklasvh/html2canvas jspdf 直接在命令行中运行npm install jspdf –savehtml2canvas 这个方法试用的版本是v0.5.0-beta4，下载方法前面有介绍。别下载错了哦。 代码方法如下（其他问题可前后结合试试，我就不试啦。）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344methods: &#123; LoadPDF() &#123; var target = document.getElementsByClassName(\"pdfbg\")[0]; //需要打印的区域 target.style.background = \"#FFFFFF\"; //设置背景色，已设置可跳过 html2canvas(target, &#123; onrendered:function(canvas) &#123; var contentWidth = canvas.width; var contentHeight = canvas.height; //一页pdf显示html页面生成的canvas高度; var pageHeight = contentWidth / 592.28 * 841.89; //未生成pdf的html页面高度 var leftHeight = contentHeight; //页面偏移 var position = 0; //a4纸的尺寸[595.28,841.89]，html页面生成的canvas在pdf中图片的宽高 var imgWidth = 595.28; var imgHeight = 592.28/contentWidth * contentHeight; var pageData = canvas.toDataURL('image/jpeg', 1.0); var pdf = new jsPDF('', 'pt', 'a4'); //有两个高度需要区分，一个是html页面的实际高度，和生成pdf的页面高度(841.89) //当内容未超过pdf一页显示的范围，无需分页 if (leftHeight &lt; pageHeight) &#123; pdf.addImage(pageData, 'JPEG', 0, 0, imgWidth, imgHeight ); &#125; else &#123; while(leftHeight &gt; 0) &#123; pdf.addImage(pageData, 'JPEG', 0, position, imgWidth, imgHeight) leftHeight -= pageHeight; position -= 841.89; //避免添加空白页 if(leftHeight &gt; 0) &#123; pdf.addPage(); &#125; &#125; &#125; pdf.save(\"save.pdf\"); //保存PDF &#125; &#125;) &#125;&#125; HTML转PDF，总体来说，我觉得只适合页面内容较少的，过多了效果并不是很理想，也许是我的方式不对吧。如果有其他方法或者不对的地方，欢迎留言指教。","tags":[{"name":"vue","slug":"vue","permalink":"https://linyong05.github.io/tags/vue/"},{"name":"JS","slug":"JS","permalink":"https://linyong05.github.io/tags/JS/"}]},{"title":"Tomato Music——移动端音乐 WebApp","date":"2018-04-18T07:11:41.000Z","path":"2018/04/18/TomatoMusic/","text":"Tomato Music——移动端音乐 WebApp👉 github: https://github.com/LinYong05/vue-music-webapp 👉 项目演示地址(接口可能会因为QQ音乐变动导致数据获取失败): https://linyong05.github.io/vue-music-webapp/dist/#/recommend （在 GitHub Pages 中，通过 jsonp 请求的数据会被正常渲染，而由于无 node 服务，通过 axios 请求的数据不会被正常渲染,最主要表现为首页推荐列表、歌词加载不来。） 基于 Vue 全家桶 (2.x) 制作的移动端音乐 WebApp ，一个媲美原生的移动端音乐App项目，功能完备，UI美观，交互一流 技术储备要求 1、精通HTML、 CSS和JavaScript编程 2、有了一定Vue.js 基础和Vue.js的实际开发经验 3、已经具备Node.js、npm和webpack的使用经验 学习知识点（前端） Vue：数据绑定及全新的逻辑体验 vue-router：为单页面应用提供的路由系统 vuex：Vue 集中状态管理，有点像临时共享仓库 vue-lazyload：第三方图片懒加载库，优化页面加载速度 better-scroll：滚动插件 ES6：ECMAScript 新一代语法，模块化、解构赋值、Promise、Class 是新的知识点 学习知识点（后端） Node.js：本地测试服务器，基于node.js开发vue项目 jsonp：服务端数据通讯。抓取 QQ音乐(移动端)数据来实现音乐的数据的获取 axios：服务端数据请求。结合 Node.js 代理后端请求，抓取 QQ音乐(PC端)数据 收获 收获了一套 Vue 通用组件，可以在其它项目中复用的 10+ 个基础组件、15+ 个业务组件 收获了一套常用的 SCSS mixin 库 体会到组件化、模块化开发带来的便捷 体会到将对象封装成类(ES6 class) 的便捷性，以及利用工厂方式初始化类实例 学会利用 js 编写过渡效果及动画效果制作良好的用户交互体验 学会了vue开发思想逻辑","tags":[{"name":"vue","slug":"vue","permalink":"https://linyong05.github.io/tags/vue/"}]},{"title":"vue笔记","date":"2018-04-17T02:58:44.000Z","path":"2018/04/17/vue笔记/","text":"前言这是我第一次学习vue时整理的一些简单的笔记。同时也是我建立这个个人博客的第一篇文章。借此分享也便以后查阅，欢迎纠正与指导。 vue目录结构说明1.build: 项目构建webpack相关代码。 2.config: 配置目录，包括端口号等。 3.node_modules: npm加载的项目依赖模块。 4.src: 这里是我们要开发的目录，基本上要做的事情都在这个目录里。 5.static: 静态资源目录:如图片、字体等。 6.package.json: 项目配置文件，这个用于控制项目的依赖。使用npm加载依赖时，会按照这个文件里描述的依赖及版本进行下载。 7.index.html: 项目入口文件 8.static/.gitkeep: 这个文件保证这个文件夹在上传到github的时候会始终存在。因为github本身会忽略掉空文件夹。 9..babelrc: babel语法编译器的编译配置 10..eslintignore: 忽略语法检查的目录 11.eslintrc.js: 语法检查eslint的配置文件 12.gitignore: 配置一些不需要上传到github的文件或者目录 13.README.md: 项目的描述文件 vue重要的指令vue对象里的设置通过html指令进行关联 12345678910111213v-text: 渲染字符串文本数据v-html: 渲染普通的html代码插入v-show: 切换元素的display属性（显示/隐藏）v-if: 按条件渲染~（条件未满足时代码不存在前端页面）v-else: 前一兄弟元素必须有 v-if 或 v-else-ifv-else-if: 前一兄弟元素必须有 v-if 或 v-else-ifv-for: 循环渲染，有相同父元素的子元素最好加个独特的 keyv-on: 绑定事件，缩写 @ v-bind: 动态地绑定一个或多个特性（src、class、style等），缩写 :v-model: 表单控件或组建上创建双向绑定v-pre: 跳过这个元素和它的子元素的编译过程v-cloak: 这个指令保持在元素上直到关联实例结束编译，防止闪烁v-once: 只渲染元素和组件一次，随后的重新渲染将跳过，这可以用于优化更新性能。 vue对象属性说明new 一个vue对象的时候你可以设置它的属性，其中最重要的包括三个，分别是data、methods、watch. data代表vue对象的数据 methods代表vue对象的方法 watch设置了对象监听的方法 mounted页面初始化默认方法,$el挂载到实例上去之后调用该钩子 computed实时计算 created在实例创建完成后被立即调用,挂载阶段还没开始，$el 属性目前不可见。 vuex状态管理Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。目录结构：store:&nbsp;&nbsp;&nbsp;&nbsp;1.action.js &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;异步修改操作&nbsp;&nbsp;&nbsp;&nbsp;2.getters.js &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四步：取数据到组件&nbsp;&nbsp;&nbsp;&nbsp;3.index.js &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;入口文件&nbsp;&nbsp;&nbsp;&nbsp;4.mutation-type.js &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二步：设置常量方法&nbsp;&nbsp;&nbsp;&nbsp;5.mutation.js &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三步：定义修改操作&nbsp;&nbsp;&nbsp;&nbsp;6.state.js &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步：定义状态树 vue学习过程中一些其他技巧或插件自定义路径别名在buidl文件夹下找到webpack.base.config.js文件根据自己需求修改 resolve:{&nbsp;&nbsp;&nbsp;&nbsp;extensions: [‘.js’, ‘.vue’, ‘.json’],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alias: {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;’vue$’: ‘vue/dist/vue.esm.js’,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‘@’: resolve(‘src’),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;’common’: resolve(‘src/common’),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;’components’: resolve(‘src/components’),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;’base’: resolve(‘src/base’),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;’api’: resolve(‘src/api’)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}} tag转换制定标签类型 &lt;router-link tag=&quot;div&quot; to=&quot;/xxx&quot;&gt; 将默认为a标签的路由导航指派为div。 路由器技巧运行项目时需要默认打开某个路由指向时，可设置 {&nbsp;&nbsp;&nbsp;&nbsp;path: ‘/‘,&nbsp;&nbsp;&nbsp;&nbsp;redirect: ‘/index’} 相关 vue组件之间的调用另一个重要选项components vue组件之间的通信props 功能模块：select、pagenation…… 页面区域：header、footer、sidebar…… class首字母大写（compenents） &lt;solt&gt;&lt;/solt&gt;vue的一个插槽 activated keep-alive组件激活时调用。当引入keep-alive的时候，页面第一次进入，钩子的出发顺序created &gt; mounted &gt; activated,退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。keep-alive只有当数据变化时，才使用更新。故，页面进入的数据获取应该在activated中也放一份。数据下载完毕手动操作DOM的部分也应该在activated中执行才会生效。 样式：flex布局 align-items:center 垂直居中flex纵向排列 flex-direction:column;justify-content:center 纵向居中 图片懒加载：vue-lazyload 引用本地资源 require(&#39;xxx.png&#39;) $el 非dom操作时添加进行修改 vue内置组件transition-group：作为多个元素/组件的过渡效果，使用时需要一个动画名称name=&quot;list&quot;，默认渲染&lt;span&gt;，可以通过 tag 属性配置哪个元素应该被渲染。渲染成ul时要求li有:key=&quot;item.id&quot;。高度从50px变成0的效果： .list-enter-active, .list-leave-active{&nbsp;&nbsp;&nbsp;&nbsp;transition: all 0.1s}.list-enter, .list-leave-to{&nbsp;&nbsp;&nbsp;&nbsp;height: 0}","tags":[{"name":"vue","slug":"vue","permalink":"https://linyong05.github.io/tags/vue/"},{"name":"笔记","slug":"笔记","permalink":"https://linyong05.github.io/tags/笔记/"}]}]